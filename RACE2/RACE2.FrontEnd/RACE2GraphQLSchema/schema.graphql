schema {
  query: Query
  mutation: Mutation
}

type Query {
  userDetails: [UserDetail!]!
  byId(id: Int!): UserDetail!
  userByEmailID(email: String!): UserSpecificDto!
  userWithRoles(email: String!): UserSpecificDto!
  matchUserWithEmailAndPasswordHash(email: String! passwordhash: String!): UserDetail!
  engineerReservoirByUUID(uuid: String!): IntegrationResponseModel!
  organisationAddressbyId(orgId: Int!): OrganisationDTO!
  featurePermissionForRole(roleid: Int!): [FeatureFunction!]!
  reservoirById(id: Int!): Reservoir!
  reservoirsByUserId(id: Int!): [ReservoirDetailsDTO!]!
  actionsListByReservoirIdAndCategory(reservoirid: Int! category: Int!): [Action!]!
  safetyMeasuresListByReservoirId(reservoirid: Int!): [SafetyMeasure!]!
  addressByReservoirId(reservoirid: Int! operatortype: String!): Address!
  operatorsforReservoir(reservoirid: Int! operatortype: String!): [OperatorDTO!]!
  reservoirsByUserEmailId(emailId: String!): [ReservoirDetailsDTO!]!
  reservoirStatusByEmail(email: String!): [SubmissionStatusDTO!]!
}

type Mutation {
  createUser(newuser: UserDetailInput!): UserDetail!
  validateUser(loginuser: UserDetailInput!): UserDetail!
  updatePasswordHashForUser(id: Int! passwordhash: String!): UserDetail!
  updateReservoir(updatedReservoir: ReservoirUpdateDetailsDTOInput!): Reservoir!
}

enum ApplyPolicy {
  BEFORE_RESOLVER
  AFTER_RESOLVER
  VALIDATION
}

type FeatureFunction {
  id: Int!
  name: String!
  displayName: String
  description: String
  start_date: DateTime!
  end_date: DateTime!
  permission: [UserPermission!]!
}

type OrganisationDTO {
  id: Int!
  orgName: String
  businessType: String
  addresses: [Address!]!
}

type IntegrationResponseModel {
  statusCode: HttpStatusCode!
  status: String
  reason: String
  responseData: String!
}

type UserSpecificDto {
  roles: [Role!]!
  reservoir: [Reservoir!]!
  addresses: [Address!]!
  race_id: String
  c_defra_id: String
  c_type: String
  c_first_name: String
  c_last_name: String
  c_mobile: String
  c_emergency_phone: String
  c_alternative_email: String
  c_alternative_mobile: String
  c_alternative_phone: String
  c_alternative_emergence_phone: String
  c_job_title: String
  c_current_panel: String
  c_paon: String
  c_saon: String
  c_status: String
  c_created_on_date: DateTime!
  c_last_access_date: DateTime!
  c_IsFirstTimeUser: Boolean!
  reservoirs: [UserReservoir!]!
  organisation: Organisation
  id: Int!
  userName: String
  normalizedUserName: String
  email: String
  normalizedEmail: String
  emailConfirmed: Boolean!
  passwordHash: String
  securityStamp: String
  concurrencyStamp: String
  phoneNumber: String
  phoneNumberConfirmed: Boolean!
  twoFactorEnabled: Boolean!
  lockoutEnd: DateTime
  lockoutEnabled: Boolean!
  accessFailedCount: Int!
}

type UserDetail {
  race_id: String
  c_defra_id: String
  c_type: String
  c_first_name: String
  c_last_name: String
  c_mobile: String
  c_emergency_phone: String
  c_alternative_email: String
  c_alternative_mobile: String
  c_alternative_phone: String
  c_alternative_emergence_phone: String
  c_job_title: String
  c_current_panel: String
  c_paon: String
  c_saon: String
  c_status: String
  c_created_on_date: DateTime!
  c_last_access_date: DateTime!
  c_IsFirstTimeUser: Boolean!
  reservoirs: [UserReservoir!]!
  addresses: [UserAddress!]!
  organisation: Organisation
  id: Int!
  userName: String
  normalizedUserName: String
  email: String
  normalizedEmail: String
  emailConfirmed: Boolean!
  passwordHash: String
  securityStamp: String
  concurrencyStamp: String
  phoneNumber: String
  phoneNumberConfirmed: Boolean!
  twoFactorEnabled: Boolean!
  lockoutEnd: DateTime
  lockoutEnabled: Boolean!
  accessFailedCount: Int!
}

type Reservoir {
  id: Int!
  raceReservoirId: String
  publicName: String
  registeredName: String
  referenceNumber: String
  publicCategory: String
  registeredCategory: String
  gridReference: String
  capacity: Int!
  surfaceArea: Int!
  topWaterLevel: Decimal!
  hasMultipleDams: Boolean!
  keyFacts: String
  constructionStartDate: DateTime!
  verifiedDetailsDate: DateTime!
  lastInspectionDate: DateTime!
  nextInspectionDate: DateTime!
  address: Address
  nearestTown: String
  userReservoirs: [UserReservoir!]!
  supportingDocuments: [SupportingDocument!]!
  operatorType: String
}

type ReservoirDetailsDTO {
  id: Int!
  raceReservoirId: String
  publicName: String
  registeredName: String
  referenceNumber: String
  publicCategory: String
  registeredCategory: String
  gridReference: String
  capacity: Int!
  surfaceArea: Int!
  topWaterLevel: Decimal!
  hasMultipleDams: Boolean!
  keyFacts: String
  constructionStartDate: DateTime!
  verifiedDetailsDate: DateTime!
  lastInspectionDate: DateTime!
  nextInspectionDate: DateTime!
  address: Address
  nearestTown: String
  operatorType: String
}

type Action {
  id: Int!
  raceActionId: String!
  reference: String!
  category: String!
  type: String!
  summary: String!
  description: String!
  frequency: String!
  priority: String!
  isComplianceAction: Boolean!
  createdDate: DateTime!
  targetDate: DateTime!
  notes: String!
  reservoir: Reservoir!
}

type SafetyMeasure {
  id: Int!
  raceSafetyMeasureId: String
  reference: String
  type: String!
  othertype: String
  description: String!
  createddate: DateTime!
  targetdate: DateTime!
  status: String!
  notes: String
  reservoir: Reservoir!
}

type Address {
  id: Int!
  raceAddressKey: String
  addressLine1: String
  addressLine2: String
  town: String
  county: String
  postcode: String
}

type OperatorDTO {
  operatorFirstName: String
  operatorLastName: String
  orgName: String
  email: String
  mobile: String
  addressLine1: String
  addressLine2: String
  town: String
  county: String
  postcode: String
}

type SubmissionStatusDTO {
  service: FeatureFunction!
  publicName: String!
  isCurrent: Boolean!
  isLegacySubmission: Boolean!
  dueDate: DateTime!
  status: String!
  lastModified: DateTime!
  modifiedBy: UserDetail!
  lastModifiedScreen: ScreenDefinition!
  submittedOn: DateTime!
  submittedBy: UserDetail!
}

input UserDetailInput {
  race_id: String
  c_defra_id: String
  c_type: String
  c_first_name: String
  c_last_name: String
  c_mobile: String
  c_emergency_phone: String
  c_alternative_email: String
  c_alternative_mobile: String
  c_alternative_phone: String
  c_alternative_emergence_phone: String
  c_job_title: String
  c_current_panel: String
  c_paon: String
  c_saon: String
  c_status: String
  c_created_on_date: DateTime!
  c_last_access_date: DateTime!
  c_IsFirstTimeUser: Boolean!
  reservoirs: [UserReservoirInput!]!
  addresses: [UserAddressInput!]!
  organisation: OrganisationInput
  id: Int!
  userName: String
  normalizedUserName: String
  email: String
  normalizedEmail: String
  emailConfirmed: Boolean!
  passwordHash: String
  securityStamp: String
  concurrencyStamp: String
  phoneNumber: String
  phoneNumberConfirmed: Boolean!
  twoFactorEnabled: Boolean!
  lockoutEnd: DateTime
  lockoutEnabled: Boolean!
  accessFailedCount: Int!
}

input ReservoirUpdateDetailsDTOInput {
  id: Int!
  userId: Int!
  publicName: String
  gridReference: String
  nearestTown: String
}

input OrganisationInput {
  id: Int!
  orgName: String
  businessType: String!
}

input UserAddressInput {
  id: Int!
  addressType: String
  userDetail: UserDetailInput
  address: AddressInput
}

input UserReservoirInput {
  id: Int!
  raceAppointmentId: String
  userDetail: UserDetailInput!
  reservoir: ReservoirInput!
  appointmentType: String
  appointmentStartDate: DateTime!
  appointmentEndDate: DateTime!
}

"The `DateTime` scalar represents an ISO-8601 compliant date time type."
scalar DateTime

type ScreenDefinition {
  id: Int!
  screenName: String!
  title: String
  hasSignificantChange: Boolean!
  modified: DateTime!
  modifiedBy: UserDetail!
}

type SupportingDocument {
  id: Int!
  fileName: String!
  fileLocation: String!
  fileType: String!
  documentName: String!
  documentDescription: String!
  documentType: String!
  documentDate: DateTime!
  documentStatus: String!
  documentAuthorName: String!
  protectiveMarking: String!
  dateSent: DateTime!
  dateReceived: DateTime!
  suppliedBy: UserDetail!
  reservoir: [Reservoir!]!
}

"The built-in `Decimal` scalar type."
scalar Decimal

type UserAddress {
  id: Int!
  addressType: String
  userDetail: UserDetail
  address: Address
}

type Organisation {
  id: Int!
  orgName: String
  businessType: String!
}

type UserReservoir {
  id: Int!
  raceAppointmentId: String
  userDetail: UserDetail!
  reservoir: Reservoir!
  appointmentType: String
  appointmentStartDate: DateTime!
  appointmentEndDate: DateTime!
}

type Role {
  c_display_name: String
  c_description: String
  c_parent_roleid: Int!
  permission: [UserPermission!]!
  id: Int!
  name: String
  normalizedName: String
  concurrencyStamp: String
}

enum HttpStatusCode {
  CONTINUE
  SWITCHING_PROTOCOLS
  PROCESSING
  EARLY_HINTS
  OK
  CREATED
  ACCEPTED
  NON_AUTHORITATIVE_INFORMATION
  NO_CONTENT
  RESET_CONTENT
  PARTIAL_CONTENT
  MULTI_STATUS
  ALREADY_REPORTED
  IM_USED
  AMBIGUOUS
  MOVED
  REDIRECT
  REDIRECT_METHOD
  NOT_MODIFIED
  USE_PROXY
  UNUSED
  TEMPORARY_REDIRECT
  PERMANENT_REDIRECT
  BAD_REQUEST
  UNAUTHORIZED
  PAYMENT_REQUIRED
  FORBIDDEN
  NOT_FOUND
  METHOD_NOT_ALLOWED
  NOT_ACCEPTABLE
  PROXY_AUTHENTICATION_REQUIRED
  REQUEST_TIMEOUT
  CONFLICT
  GONE
  LENGTH_REQUIRED
  PRECONDITION_FAILED
  REQUEST_ENTITY_TOO_LARGE
  REQUEST_URI_TOO_LONG
  UNSUPPORTED_MEDIA_TYPE
  REQUESTED_RANGE_NOT_SATISFIABLE
  EXPECTATION_FAILED
  MISDIRECTED_REQUEST
  UNPROCESSABLE_ENTITY
  LOCKED
  FAILED_DEPENDENCY
  UPGRADE_REQUIRED
  PRECONDITION_REQUIRED
  TOO_MANY_REQUESTS
  REQUEST_HEADER_FIELDS_TOO_LARGE
  UNAVAILABLE_FOR_LEGAL_REASONS
  INTERNAL_SERVER_ERROR
  NOT_IMPLEMENTED
  BAD_GATEWAY
  SERVICE_UNAVAILABLE
  GATEWAY_TIMEOUT
  HTTP_VERSION_NOT_SUPPORTED
  VARIANT_ALSO_NEGOTIATES
  INSUFFICIENT_STORAGE
  LOOP_DETECTED
  NOT_EXTENDED
  NETWORK_AUTHENTICATION_REQUIRED
}

type UserPermission {
  id: Int!
  access_level: String!
  start_date: DateTime
  end_date: DateTime
}

input ReservoirInput {
  id: Int!
  raceReservoirId: String
  publicName: String
  registeredName: String
  referenceNumber: String
  publicCategory: String
  registeredCategory: String
  gridReference: String
  capacity: Int!
  surfaceArea: Int!
  topWaterLevel: Decimal!
  hasMultipleDams: Boolean!
  keyFacts: String
  constructionStartDate: DateTime!
  verifiedDetailsDate: DateTime!
  lastInspectionDate: DateTime!
  nextInspectionDate: DateTime!
  address: AddressInput
  nearestTown: String
  userReservoirs: [UserReservoirInput!]!
  supportingDocuments: [SupportingDocumentInput!]!
  operatorType: String
}

input AddressInput {
  id: Int!
  raceAddressKey: String
  addressLine1: String
  addressLine2: String
  town: String
  county: String
  postcode: String
}

input SupportingDocumentInput {
  id: Int!
  fileName: String!
  fileLocation: String!
  fileType: String!
  documentName: String!
  documentDescription: String!
  documentType: String!
  documentDate: DateTime!
  documentStatus: String!
  documentAuthorName: String!
  protectiveMarking: String!
  dateSent: DateTime!
  dateReceived: DateTime!
  suppliedBy: UserDetailInput!
  reservoir: [ReservoirInput!]!
}